# RacingImageViewer
---
> 특정 페이지(https://www.gettyimagesgallery.com/collection/auto-racing/)를 http로 받아와 갤러리에 포함된 이미지를 list또는 grid로 표현하는 앱

## Index
1. 기능
2. 앱 구조 
3. 트러블 슈팅
---

1. 기능
    * 지정된 URL의 웹페이지를 http 요청을 통해 읽어와서 파싱해서, 갤러리의 이미지 링크들을 추출한다.(Kanna 라이브러리 이용)
    * 추출한 이미지 링크로 다시 http 요청을 해서 이미지 데이터를 가져와 테이블 뷰를 통해 list 형태로 띄워준다.
    * 아직 로딩되지 않은 이미지는 이를 대체하는 placeholder를 띄워준다.
    * 웹페이지와 이미지 데이터가 성공했다면, 결과가 캐시되어 다시 요청할 때 추가적인 네트워크 요청 없이 데이터를 사용할 수 있다.
    * TableViewDelegate를 통해서 이미지의 크기를 동적으로 계산한다.*
    * Prefetching을 적용하여 좀 더 부드러운 스크롤링을 지원한다.
    * 네트워크 오류가 발생할 경우 상황에 따라 다른 액션을 지원한다.
      * 페이지 로딩이 실패할 경우, alert을 띄워고 확인 버튼을 눌러 재시도 하도록 한다.
      * 이미지 로딩이 실패할 경우, placeholder 이미지를 그대로 띄워준다.
    * 페이지 로딩시 네트워크 인디케이터를 띄워주고, 로딩이 끝나면 이를 꺼준다.
    * 셀별로 이미지 로딩시 네트워크 인디케이터를 띄워주고, 로딩이 끝나면 이를 꺼준다.

2. 앱 구조
    
    ![App Structure](/Image/RacingImageViewerAppStructure.png)

    * 앱 아키텍처 - MVVM
      *  M(Model): 네트워크 요청을 수행하고, 요청한 데이터를 캐싱한다.
      *  V(View): 뷰모델과 서로 바인딩해서, 뷰모델의 변화에 맞게 뷰를 변화시킨다. 또한 Command 객체를 만들어 뷰모델에 전달해서 변화를 유발시킨다. 또한 뷰모델에서 받은 데이터를 캐싱해서, Delegate등에서 사용한다.
      *  VM(ViewModel): 모델에 필요한 데이터를 요청하고 비즈니스 로직을 수행해서 뷰를 변화시킨다. 비즈니스 로직의 일부는 Command에 담겨서 전달된다.

3. 트러블 슈팅

   1. 캐시 동기화 문제 
   
      * 상황: Dictionary를 이용해서 이미지 데이터를 캐싱하도록 구현했더니, 간헐적으로 앱이 크래시되는 상황이 발생
   
      * 원인: 동기화 과정 없이 한 변수에 여러 스레드가 동시에 접근해서 수정했기 때문
   
      * 해결
        * Thread Sanitizer로 검증해서 이상이 생기는 부분에 Foundation에서 제공하는 NSLock을 이용해 앞뒤로 lock을 걸어 스레드를 동기화시킴.
        * 이후 lock을 수동으로 사용하는 코드가 번거롭고 메모리 부족시 자동으로 캐시를 비우는 기능을 적용하기 위해, Foundation에서 제공하는 NSCache클래스를 사용.
        * NSCache 클래스는 클래스 타입만 사용할 수 있는 제한이 있어서, 구조체인 Value Object를 지원하기 위해 DataWrapper 클래스를 추가로 만들어 사용.
    
   2. 셀의 네트워크 인디케이터 문제

      * 상황: 이미지를 로딩할 때, 간헐적으로 네트워크 인디케이터가 제대로 꺼지지 않고 이미지 위에 그대로 남는 경우 발생
      * 원인
         * 셀에서 이미지를 요청할 때와 프리패칭을 할 때 같은 Operation 객체를 공유하는데, 프리패칭을 할 때는 셀의 프로퍼티를 참조할 수 없기 때문에 단순히 요청만 함.
          
         * 따라서 셀에서 이 Operation 객체를 따로 참조해서 CompletionHandler와 ErrorHandler를 주입하고 있었음.
          
         * 문제는 이 모든 과정이 비동기적으로 이루어지기 때문에, 핸들러가 제대로 주입되기 전에 Operation이 끝나버리는 경우가 있음.
          
         * 특히 이러한 문제는 네트워크 오류가 발생했을 때 더욱 빈번하게 발생했음
         
       * 해결 
         * Operation 기반 프리패칭을 대신하여 이미지 데이터를 가져오기 위해 뷰모델을 추가로 정의했다.
           
         * Operation을 대신해서 Observable을 적용했고, 이 Observable을 캐싱해서 반복적인 요청에도 중복된 요청을 하지 않게 만들었다. 

   3. 요청 캐싱 문제

       * 상황: 요구 사항이 바뀌는 경우에 Observable 캐시의 내용이 무용지물이 된다.  
          
       * 원인  
          * 요청한 데이터 자체가 아닌 가공된 데이터를 캐싱했기 때문이다.  
            
          * 데이터 요청과 데이터 가공이 하나의 모델에서 이루어지고 있었기 때문이다.  
          
       * 해결  
          * 모델에서는 데이터 요청만 하도록 함. 요청을 통해 받은 Data를 그대로 캐싱하기 때문에 데이터 가공 로직이 바뀌어도 캐시를 다시 사용 가능  
            
          * 뷰모델에서 command 안에 있는 가공 메소드를 통해 데이터를 가공함  
    
   4. 뷰모델의 Relay 동기화 문제  
       
      * 상황: 콘솔에서 'Reentrancy anomaly was detected.' 메시지가 떴다.  

      * 원인  
        * 뷰모델이 요청을 받을 때마다 Subscription이 생기고, 이 Subscription은 이벤트를 받아서 Relay에 값을 전달하게 됨.  

        * 하나의 뷰모델이 요청을 여러번 받게 되면서 Subscription이 여러 개 생기고, 이 때 Relay에 Race Condition이 생기게 됨.  

      * 해결  
        * relay에 접근하는 코드 앞뒤로 lock을 걸고 해제하는 코드 추가  


